platform='unknown'
unamestr=`uname`
if [[ "$unamestr" == 'Linux' ]]; then
   platform='linux'
   alias ls='ls --color=auto'
   alias ll='ls --color=auto -l'
elif [[ "$unamestr" == 'Darwin' ]]; then
   platform='mac'
   alias ls='ls -G'
   alias ll='ls -G -l'
   alias go=open
   alias gvim='mvim -c "set guifont=Menlo:h12"'
   alias vim='mvim -v'


   bindkey 'OH' beginning-of-line
   bindkey 'OF' end-of-line

   bindkey  '^[[5~'    history-beginning-search-backward
   bindkey  '^[[6~'  history-beginning-search-forward
fi

jsonb() {
    for file in $@; do
        echo $file
        cat $file | python -m json.tool > $file.beautiful && mv -f $file.beautiful $file
        if [[ -f $file.beautiful ]]; then
            rm $file.beautiful
        fi
    done
}

source ~/.dotfiles/zsh/zsh-common
function custom_pwd () {
    g4_path_pattern=`echo $PWD|sed 's/^\/google\/src\/cloud\/\([^/]\+\)\/\([^/]\+\)\/google3\/\?\(.*\)/\1 \2 \3/'`
    eval "tokens=($g4_path_pattern)"
    if [ -n "${tokens[2]}" ]; then
        result="%{$fg_bold[blue]%}${tokens[1]}%{$reset_color%}(%{$fg_bold[magenta]%}${tokens[2]}%{$reset_color%}) google3: %{$fg_bold[yellow]%}//${tokens[3]}"
    else
        git5_path_pattern=`echo $PWD|sed 's/^\/usr\/local\/google\/home\/tgeng\/git\/\([^/]\+\)\/\(google3\)\/\?\(.*\)/\1 \2 \3/'`
        eval "git5_tokens=($git5_path_pattern)"
        if [ -n "${git5_tokens[2]}" ]; then
            result="%{$fg_bold[blue]%}Git5%{$reset_color%}(%{$fg_bold[magenta]%}${git5_tokens[1]}%{$reset_color%}) %{$fg_bold[yellow]%}//${git5_tokens[3]}"
        else
            result="%~"
        fi
    fi
print $result
}
if [ -n "$CUSTOM_PROMPT" ]; then
  PROMPT=$CUSTOM_PROMPT
else
  PROMPT='%{$fg_bold[green]%}%T %{$fg_bold[yellow]%}$(custom_pwd)%b$(git_super_status) %{$fg_bold[green]%}$ %{$reset_color%}'
fi
setopt promptsubst
setopt menu_complete
setopt complete_aliases
#export LANG=C

# zsh completion

if [ -e /usr/share/terminfo/x/xterm-256color ]; then
        export TERM='xterm-256color'
else
        export TERM='xterm-color'
fi

export LSCOLORS=exgxcxdxcxegedcaCaacad

# no need to re-parse for completition
zstyle ':completion:*' use-cache on
zstyle ':completion:*' cache-path ~/.zsh/cache

source ~/bin/bashmarks.sh


# Use ADB turbo whenever possible - otherwise fallback to standard adb.
function adb() {
  EMU_DEPS=/google/data/ro/teams/mobile_eng_prod/emu/live/google3/
  ANDROID_SDK=${EMU_DEPS}/third_party/java/android/android_sdk_linux/
  EMU_SUPPORT=${EMU_DEPS}/tools/android/emulator/support/
  ANDROID_ADB=${ANDROID_SDK}/platform-tools/adb
  ANDROID_ADB=${ANDROID_ADB} $EMU_SUPPORT/adb.turbo "$@"
}

cd `cat ~/.current_pwd`

cdg() {
    cd `echo $PWD |  sed 's/\(^.*google3\).*/\1/'`
}
# alias cd=cl
alias cdj='cd /usr/local/google/users/tgeng/magicjar'

alias vex=/home/build/static/projects/vex/vex
alias orgconsole=/google/data/ro/projects/hr/db/bin/console
alias open=gnome-open


pathto(){
    echo -n $PWD/$1 | xclip -selection clipboard
}
bpath(){
    echo -n $PWD$1 | perl -pe 's|^.*?google3/?(.*)|//\1|'| xclip -selection clipboard
}
alias todo='vim ~/todo.md'

sj(){
    if [[ $PWD =~ \/javatests\/ ]]; then
        newPWD=`echo $PWD | sed -r 's/\/javatests\//\/java\//'`
        if [ -d "$newPWD" ]; then
            cd $newPWD
        else
            echo "Corresponding java directory doesn't exist. Created for you."
            mkdir -p $newPWD && cd $newPWD || echo Cannot create directory $newPWD
        fi
    elif [[ $PWD =~ \/java\/ ]]; then
        newPWD=`echo $PWD | sed -r 's/\/java\//\/javatests\//'`
        if [ -d "$newPWD" ]; then
            cd $newPWD
        else
            echo "Corresponding javatests directory doesn't exist. Created for you."
            mkdir -p $newPWD && cd $newPWD || echo Cannot create directory $newPWD
        fi
    fi
    newPWD=''
}
sp(){
    if [[ $PWD =~ \/home\/tgeng\/git\/.+ ]]; then
      newPWD=`echo $PWD | sed -r "s|/git/[^/]+|/git/$1|"`
      if [ -d "$newPWD" ]; then
          cd $newPWD
      else
          echo "Corresponding directory under project $1 does not exist."
      fi
    fi
    newPWD=''
}

alias nemo='nemo --no-desktop'
alias cdd='cd ~/Dropbox'
stty -ixon


meldsub() {
meld /google/src/cloud/tgeng/{$2,$3}/google3/java/$1 &
meld /google/src/cloud/tgeng/{$2,$3}/google3/javatests/$1 &
}

'='() {
calc $@
}
alias msgbus=/google/data/ro/projects/corpmb/msgbus
alias jade='/google/data/ro/teams/jade/jade'
alias fido='/google/src/head/depot/google3/caribou/localconfig/eclipse/tools/fido/fido.sh'
alias mysqlg=/google/data/ro/projects/speckle/mysql
alias apido=/google/data/ro/teams/oneplatform/apido
alias generic_corpus=/google/data/ro/teams/generic-corpus/generic_corpus

# for the g4d autocomplete
source /etc/bash_completion.d/g4d
git() { if [[ $1 == 'merge' ]]; then echo 'Use git5 merge, not git merge. git merge does not understand how to merge the READONLY link and it can corrupt your branch, so stay away from it.  type "unset -f git" to remove this warning'; else command git "$@"; fi; }

alias gitc='git checkout'
gitcfb() {
    if ! git checkout -b $1; then
        read -q "REPLY?Do you want to drop branch '$1'? (y/N) "
        case $REPLY in
            [yY][eE][sS]|[yY])
                echo
                git branch -D $1 && git checkout -b $1
                ;;
            *)
                echo "Aborted."
                ;;
        esac
    fi
}
gitco() {
    if [ -z "$1" ]; then
        git commit -a --amend --no-edit
    else
        git commit -am $1
    fi
}
gitx() {
    gitco 'update'
    buildifier -a -v
    git5 fix
    git5 export
}
gitcox() {
    if [ -z "$1" ] || [ -n "$2"  ]; then
        echo "Must provide a commit message."
        return 1
    fi
    if git5 pending | grep '(current)' > /dev/null; then
        echo "Found existing CITC client."
        git5 drop
    fi
    if  git5 pending | grep '(current)' > /dev/null; then
        echo "Nothing is exported."
    else
        gitco "$1"
        buildifier -a -v
        git5 fix
        git5 export -d "$1"
    fi
}
gitct() {
  branch=$(git status | head -n 1 | cut -f 4 -d ' ')
  working_dirty=''
  if ! git status | grep 'nothing to commit, working directory clean' > /dev/null; then
    working_dirty='YES'
    git stash
  fi
  git checkout $1
  git5 sync

  echo $PWD > ~/.current_pwd
  export CUSTOM_PROMPT="%{$fg_bold[red]%}[TEMP] $PROMPT"; zsh

  gitx
  git checkout $branch
  echo $working_dirty
  if [ -n "$working_dirty" ]; then
    echo 'popping stash'
    git stash pop
  fi
}
alias gits='git status'
alias gitb='git branch'
alias git5s='git5 status'
alias git5d='git5 diff --stat'
alias git5cln='git5 cleanup'
alias bclnr='build_cleaner'
# alias bclnrall='build_cleaner :all & sj ; build_cleaner :all ; fg'
alias findcells=/google/data/ro/teams/org-tools-sre/findcells
alias gcloud='/google/data/ro/teams/oneplatform/opgcloud'
alias nvim='TERM=xterm-256color nvim'
alias model-t='/google/data/ro/teams/model-t/model-t'

bclnrall() {
  cdg
  targets=($(gits --porcelain | cut -d ' ' -f 3 | sed 's|^google3/||' |sed 's|/[^/]\+$|:all|' | sort | uniq))
  for target in $targets; do
    echo "Clean up $target"
    build_cleaner $target &
  done
  cd -
  for target in $targets; do
    fg
  done
}
cdt() {
    cd $1 2> /dev/null || cd $(dirname $1)
}
vimb() {
  if [ -d $1 ]; then
    dir=$1
  else
    dir=$(dirname $1)
  fi
  if ! [ -d $dir ]; then
    echo "No valid directory specified"
    return 1
  fi
  build_path="$dir/BUILD"
  vim $build_path
}

if [ -n "$TMUX_RUNNING" ]; then
else
  export TMUX_RUNNING=YES
  export TERM=xterm-256color
  tmx -2;exit
fi

